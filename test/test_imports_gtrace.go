// Code generated by gtrace. DO NOT EDIT.

package test

import (
	"context"

	"github.com/enosi/gtrace/test/internal"
)

// Compose returns a new TraceNoShortcut which has functional fields composed
// both from t and x.
func (t TraceNoShortcut) Compose(x TraceNoShortcut) (ret TraceNoShortcut) {
	switch {
	case t.OnSomethingA == nil:
		ret.OnSomethingA = x.OnSomethingA
	case x.OnSomethingA == nil:
		ret.OnSomethingA = t.OnSomethingA
	default:
		h1 := t.OnSomethingA
		h2 := x.OnSomethingA
		ret.OnSomethingA = func(t Type) {
			h1(t)
			h2(t)
		}
	}
	switch {
	case t.OnSomethingB == nil:
		ret.OnSomethingB = x.OnSomethingB
	case x.OnSomethingB == nil:
		ret.OnSomethingB = t.OnSomethingB
	default:
		h1 := t.OnSomethingB
		h2 := x.OnSomethingB
		ret.OnSomethingB = func(t internal.Type) {
			h1(t)
			h2(t)
		}
	}
	return ret
}

type traceNoShortcutContextKey struct{}

// WithTraceNoShortcut returns context which has associated TraceNoShortcut with it.
func WithTraceNoShortcut(ctx context.Context, t TraceNoShortcut) context.Context {
	return context.WithValue(ctx,
		traceNoShortcutContextKey{},
		ContextTraceNoShortcut(ctx).Compose(t),
	)
}

// ContextTraceNoShortcut returns TraceNoShortcut associated with ctx.
// If there is no TraceNoShortcut associated with ctx then zero value
// of TraceNoShortcut is returned.
func ContextTraceNoShortcut(ctx context.Context) TraceNoShortcut {
	t, _ := ctx.Value(traceNoShortcutContextKey{}).(TraceNoShortcut)
	return t
}

func (t TraceNoShortcut) onSomethingA(ctx context.Context, t1 Type) {
	c := ContextTraceNoShortcut(ctx)
	var fn func(Type)
	switch {
	case t.OnSomethingA == nil:
		fn = c.OnSomethingA
	case c.OnSomethingA == nil:
		fn = t.OnSomethingA
	default:
		h1 := t.OnSomethingA
		h2 := c.OnSomethingA
		fn = func(t Type) {
			h1(t)
			h2(t)
		}
	}
	if fn == nil {
		return
	}
	fn(t1)
}
func (t TraceNoShortcut) onSomethingB(ctx context.Context, t1 internal.Type) {
	c := ContextTraceNoShortcut(ctx)
	var fn func(internal.Type)
	switch {
	case t.OnSomethingB == nil:
		fn = c.OnSomethingB
	case c.OnSomethingB == nil:
		fn = t.OnSomethingB
	default:
		h1 := t.OnSomethingB
		h2 := c.OnSomethingB
		fn = func(t internal.Type) {
			h1(t)
			h2(t)
		}
	}
	if fn == nil {
		return
	}
	fn(t1)
}
